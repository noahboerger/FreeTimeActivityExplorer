package org.dhbw.mosbach.ai.pizzafactory.articleservice.testhelper;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.List;

import org.apache.commons.beanutils.BeanUtils;
import org.apache.commons.beanutils.ConvertUtils;
import org.apache.commons.beanutils.Converter;
import org.apache.cxf.endpoint.Client;
import org.apache.cxf.service.model.BindingMessageInfo;
import org.apache.cxf.service.model.BindingOperationInfo;
import org.apache.cxf.service.model.MessagePartInfo;
import org.apache.cxf.service.model.OperationInfo;

import com.google.common.collect.HashBasedTable;
import com.google.common.collect.Table;

/**
 * Wrapper around {@link Client} that tries to copy properties of javabean
 * parameters to the actual ones used by the client.
 *
 * @author Alexander.Auch
 *
 */
public class ClientWrapper
{
	private final Client client;
	private final Table<String, String, Class<?>> transportObjectTable;

	private final Converter clientBeanConverter = new Converter()
	{
		@Override
		public <T> T convert(Class<T> type, Object value)
		{
			try
			{
				final T t = type.newInstance();

				BeanUtils.copyProperties(t, value);

				return t;
			}
			catch (InstantiationException | IllegalAccessException e)
			{
				throw new IllegalArgumentException(String.format("Could not create instance of type %s", type.getName()));
			}
			catch (final InvocationTargetException e)
			{
				throw new IllegalArgumentException(String.format("Could not copy values from instance of %s to instance of %s",
						value.getClass().getName(), type.getName()));
			}
		}
	};

	public ClientWrapper(Client client)
	{
		this.client = client;
		this.transportObjectTable = getTransportObjectTable(client);
		registerConverters();
	}

	private void registerConverters()
	{
		transportObjectTable.values().stream().forEach(clazz ->
		{
			try
			{
				registerConverterForClass(clazz);
			}
			catch (final ClassNotFoundException e)
			{
				throw new IllegalArgumentException(String.format("Could not load class %s", clazz.getName()), e);
			}
		});
	}

	private void registerConverterForClass(Class<?> clazz) throws ClassNotFoundException
	{
		if (ConvertUtils.lookup(clazz) != null)
			return;

		addDefaultConverter(clazz);

		for (final Field field : clazz.getDeclaredFields())
		{
			if (isClientClass(field.getType()))
			{
				registerConverterForClass(field.getType());
			}

			// Check for generic args, i.e., List<Whatever>
			if (field.getGenericType() instanceof ParameterizedType)
			{
				final ParameterizedType genericType = (ParameterizedType) field.getGenericType();

				for (final Type actualTypeArgument : genericType.getActualTypeArguments())
				{
					final Class<?> genericClass = Thread.currentThread().getContextClassLoader()
							.loadClass(actualTypeArgument.getTypeName());

					if (isClientClass(genericClass))
					{
						registerConverterForClass(genericClass);
					}
				}
			}
		}
	}

	public void addDefaultConverter(Class<?> clazz)
	{
		ConvertUtils.register(clientBeanConverter, clazz);
	}

	/**
	 * Tries to invoke the soap method by copying javabean properties from the
	 * given parameters to the ones that were generated by Apache CXF on the fly.
	 *
	 * @param methodName
	 *          method to be invoked
	 * @param args
	 *          arguments
	 * @return result objects
	 * @throws Exception
	 */
	public Object[] invoke(String methodName, Object... args) throws Exception
	{
		final Object[] transportArgs = new Object[args.length];

		for (int i = 0; i < args.length; i++)
		{
			if (args[i] != null)
			{
				final String argName = args[i].getClass().getSimpleName();

				if (String.class.isAssignableFrom(args[i].getClass()) || args[i].getClass().isPrimitive())
				{
					transportArgs[i] = args[i];
				}
				else
				{
					final Class<?> transportClass = transportObjectTable.get(methodName, argName);

					if (transportClass == null)
						throw new IllegalArgumentException(String.format("Unknown argument of type %s", argName));

					try
					{
						final Object instance;

						if (String.class.isAssignableFrom(transportClass))
						{
							instance = args[i].toString();
						}
						else
						{
							// create instance of target transport class and copy bean
							// properties
							instance = transportClass.newInstance();
							BeanUtils.copyProperties(instance, args[i]);
						}

						transportArgs[i] = instance;
					}
					catch (InstantiationException | IllegalAccessException e)
					{
						throw new IllegalArgumentException(
								String.format("Could not create an instance of class %s", transportClass.getName()));
					}
					catch (final InvocationTargetException e)
					{
						throw new IllegalArgumentException("Error while copying properties", e);
					}
				}
			}
		}

		return client.invoke(methodName, transportArgs);
	}

	private static Table<String, String, Class<?>> getTransportObjectTable(Client client)
	{
		final Table<String, String, Class<?>> attributeToClassMap = HashBasedTable.create();

		for (final BindingOperationInfo boi : client.getEndpoint().getBinding().getBindingInfo().getOperations())
		{
			final OperationInfo oi = boi.getOperationInfo();
			final BindingMessageInfo inputMessageInfo = boi.getInput();
			final List<MessagePartInfo> parts = inputMessageInfo.getMessageParts();

			final String soapMethodName = oi.getName().getLocalPart();

			// final List<String> inputParams =
			// ServiceModelUtil.getOperationInputPartNames(oi);
			// System.out.println("input parameters: " + inputParams);

			for (final MessagePartInfo partInfo : parts)
			{
				final Method[] methods = partInfo.getTypeClass().getMethods();
				for (final Method method : methods)
				{
					// tries to get the soap methods parameters by looking for specific
					// getters of the partinfo object
					if (method.getName().startsWith("get"))
					{
						final Class<?> returnType = method.getReturnType();

						if (isClientClass(returnType))
						{
							attributeToClassMap.put(soapMethodName, returnType.getSimpleName(), returnType);
						}
					}
				}
			}
		}

		return attributeToClassMap;
	}

	private static boolean isClientClass(Class<?> clazz)
	{
		return clazz.getName().startsWith("org.dhbw.mosbach.");
	}
}
